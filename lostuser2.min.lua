if debug.upvalueid then goto a end;if require then component=require'component'computer=require'computer'else if not print then print=function()end end end;proxy=function(b)local c=component.list(b)()return c and component.proxy(c)or nil end;do local d={}for e,f in pairs(component.list())do d[#d+1]={f,e}end;table.sort(d,function(g,h)return#g[1]<#h[1]end)for i,f in pairs(d)do _G[f[1]:sub(1,1):upper()]=component.proxy(f[2])end end;sleep=os and os.sleep or function(j)local k=computer.uptime;local l=k()+(j or 0)repeat computer.pullSignal(l-k())until k()>=l end::a::local function m(j)table.sort(j,function(g,h)return#g<#h end)end;local function n(o,p)local j,q={},'^'..o:gsub('.','%1.*')for e in pairs(p)do if type(e)=='string'and e:match(q)then j[#j+1]=e end end;m(j)return j[1]end;local r;local function s(t)return function(i,...)local u=table.pack(t(...))for e,f in pairs(u)do u[e]=r(f)end;return table.unpack(u)end end;r=function(j)local v=type(j)if v~='table'and v~='function'then return j end;local w=getmetatable(j)if w and w.__short then return j end;local x={__short=true,__call=s(j),__mul=s(j),__tostring=function()return'{short}'..tostring(j)end}if v=='function'then return setmetatable({},x)end;x.__index=function(self,y)local z=j[y]local f;if z~=nil then f=z else if y:match'^[A-Z]'then local A=y:sub(1,1)local B=j[A]if B then local C=y:sub(2)f=B[n(C,B)]end end;if f==nil then f=j[n(y,j)]end end;return r(f)end;x.__newindex=j;x.__pairs=function(i)return function(i,e)local e,f=next(j,e)return e,r(f)end,j,nil end;x.__len=function()return#j end;return setmetatable({},x)end;local D;local E=0;local F=0;local function G()F=F+1;return F-1 end;local function H(I,J,K)return D(I:sub(J,K)):gsub('\n','\n'..('  '):rep(E))end;local L='[_%a][_%a%d]*'local M=L..'[,_%a%d]*'local function N(O)return function(P)local J,K=P:match'(){()'if not J then return''end;local Q=P:sub(1,J-1)local S=H(P,K,-2)if type(O)=='function'then return O(Q,S)or''else return O:gsub('HEAD',Q):gsub('BODY',S)end end end;local function T(I,U,K)return I:gsub('^'..U..'([^_%a%d])',K..'%1'):gsub('([^_%a%d])'..U..'$','%1'..K):gsub('([^_%a%d])'..U..'([^_%a%d])','%1'..K..'%2')end;local V={}local function W(q,X)V[#V+1]={q,X}end;local function Y(Z,O)W(Z..'(.-%b{})',N(O))end;W('`T',[[~:Tg(){?!v{tr}}]])W('`Z',[[a=`!a ;; ??`!Rm(3){ Rtn(a) c=`!Rm(3) Rtn(a) ??c{Rtn(a)Rm(3)} a=`!a}]])W('`&',' and ')W('`!',' not ')Y('@',W)local function _(a0,S,a1)return[[

local __if = (]]..a0 ..[[)
if __if ]]..(a1 and[[and __if ~= '' and __if ~= 0 ]]or'')..[[then
  ]]..S..[[

end
]]end;Y('?%?',_('HEAD','BODY',true))Y('?%.',[[
if type(HEAD)=='table' then
    HEAD.BODY
end
]])Y('?!',[[
local __p = HEAD
if type(__p)=='table' and (type(__p.BODY)=='table' or type(__p.BODY)=='function') then
  HEAD.BODY()
end
]])Y('~#',function(Q,S)local a2='i'..G()S=T(S,'i',a2)Q=T(Q,'i',a2)local a3=Q~=nil and not Q:match"^%s*$"return'for '..a2 ..'=1, R.inventorySize(), 1 do\n'..(a3 and _(Q,S,true)or S)..'\nend 'end)Y('~:',function(Q,S)local a4=G()S=T(S,'k','k'..a4)S=T(S,'v','v'..a4)return'for k'..a4 ..', v'..a4 ..' in pairs('..Q..') do\n'..S..'\nend 'end)Y('~~',function(Q,S)local a2='i'..G()S=T(S,'i',a2)return'for '..a2 ..'='..Q..', 1 do\n'..S..'\nend 'end)local a5=true;function on_first_run(O)if a5 then O()a5=false end end;W('(.+);;(.*)',function(a6,C)return'on_first_run(function()\n  '..a6 ..'\n  \nend)\n'..C end)D=function(a7)E=E+1;local u=a7;local a2=1;while a2<=#V do u=u:gsub(V[a2][1],V[a2][2])a2=a2+1 end;E=E-1;return u end;local a8=r(_ENV)local function a9(aa)local ab=D(aa)if ab==nil or ab:match'^%s*$'then return end;ab=ab:gsub('^%s*',''):gsub('%s*$',''):gsub('[%s\n]*\n','\n')print('\n'..ab)local ac,ad=load(ab,nil,nil,a8)if ad then print(ad)else while not ac()do if debug.upvalueid then os.exit(0)end end end end;if debug.upvalueid then os.exit(0)end;local ae=({...})[1]or R.name()for af in ae:sub(1,5):gmatch"%S"do computer.beep(200+af:byte()*10,0.05)end;a9(ae)