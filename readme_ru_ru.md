
# `Lost User` - Самый Простой Робот

> ### ⚠️ Внимание
> 
> Этот гайд написан под версию *LostUser* `3.8.0`
> 

Программа BIOS для робота (или дрона!) для мода Minecraft OpenComputers.

- [`Lost User` - Самый Простой Робот](#lost-user---самый-простой-робот)
  - [Зачем?](#зачем)
  - [Установка](#установка)
    - [Сборка](#сборка)
    - [E2E-E](#e2e-e)
    - [Запись программы на EEPROM](#запись-программы-на-eeprom)
    - [Вставка в робота](#вставка-в-робота)
  - [Использование](#использование)
  - [Синтаксис](#синтаксис)
    - [Операторы и выражения](#операторы-и-выражения)
      - [Выполнение](#выполнение)
      - [Возврат](#возврат)
    - [Глобальные переменные](#глобальные-переменные)
  - [Сокращение](#сокращение)
  - [Lodash `_`](#lodash-_)
    - [Индексация `_`](#индексация-_)
    - [Вызов `_`](#вызов-_)
  - [Функциональное Программирование](#функциональное-программирование)
    - [Приоритет](#приоритет)
    - [Map `^`, `+`, или `&`](#map---или-)
    - [Лямбда `-` `/` `|`](#лямбда----)
    - [Цикл `~` или `*`](#цикл--или-)
    - [Унарные операторы](#унарные-операторы)
    - [Истинные значения](#истинные-значения)
  - [Макросы](#макросы)
  - [Примеры](#примеры)
  - [Дополнительно](#дополнительно)
    - [Числовой Словарь](#числовой-словарь)
  - [Ссылки](#ссылки)


## Зачем?

Роботы OC сложны в сборке и программировании. Эта программа BIOS помогает использовать роботов как "пользователей" и многими другими способами.

## Установка

### Сборка

Соберите робота в минимальной конфигурации:

- Корпус
- ЦПУ
- ОЗУ

<img src="https://i.imgur.com/sBP2y0N.png" width="350">

### E2E-E

Если вы играете в [Enigmatica 2: Expert - Extended](https://www.curseforge.com/minecraft/modpacks/enigmatica-2-expert-extended), в модпаке есть предопределенный рецепт EEPROM.
Найдите его в JEI и создайте. У него будет цветное свечение.

![Создание EEPROM](https://i.imgur.com/GuT7Ke6.gif)

Если вы его создали, можете пропустить следующий шаг `Запись программы на EEPROM`.

### Запись программы на EEPROM

> Вам понадобится рабочий компьютер OC для записи BIOS. Смотрите [этот учебник](https://www.youtube.com/watch?v=KDqXJzacdQQ) чтобы собрать ваш первый компьютер.

1. Скачайте файл из интернета (требуется ![Интернет-карта](https://is.gd/zrPusF 'Интернет-карта')), запустите из командной строки:

```shell
wget https://raw.githubusercontent.com/Krutoy242/lostuser/main/lostuser.min.lua
```

2. Чтобы записать на существующий EEPROM, запустите:

```shell
flash -q lostuser.min.lua LostUser
```

### Вставка в робота

Возьмите EEPROM из корпуса компьютера и вставьте его в робота.

![Соединение робота с EEPROM](https://i.imgur.com/7AHXvdm.png)

## Использование

Программируйте робота, **переименовывая его**. Переименуйте робота на ![Наковальне](https://is.gd/pYpuM1 'Наковальня') или с помощью ![Маркера](https://is.gd/VgGaLN 'Маркер').

Назовите вашего робота `robot.use(3)`, поставьте его на землю, включите и смотрите, как он кликает блоки перед собой.

![Робот активирует рычаг](https://i.imgur.com/ATnKS34.gif)

## Синтаксис

**Кратко**

Если вы не хотите изучать Lua и вам нужно, чтобы робот кликал правой/левой кнопкой мыши, вот несколько простых имен для робота и результат:

- `robot.use(3)` - Робот будет кликать правой кнопкой мыши по блоку перед собой.
- `robot.swing(3)` - Робот будет махать мечом или ломать блок перед собой.

### Операторы и выражения

#### Выполнение

Робот будет выполнять свое имя как код Lua в цикле `while true`.

Код может быть выполнен в любом варианте - `оператор` или `выражение`, но все равно должен следовать правилам потока кода Lua.

> Это оператор
> ```lua
> sleep(1)
> ```
>
> Это выражение
> ```lua
> 1, sleep(1)
> ```
>
> Комбинирование оператора и выражения
> ```lua
> a = robot.move(3) return a and robot.use(0)
> ```

#### Возврат

Если выражение возвращает одну или несколько функций, они будут выполнены рекурсивно.

Обратите внимание, что все возвращаемые значения рассчитываются сначала, и только потом будут вызваны функции.

> Вызов `robot.use(3)`, а затем `sleep()`
> ```lua
> function() return sleep end, robot.use(3)
> ```

### Глобальные переменные

<!-- components -->
1. Все компоненты доступны как глобальные переменные.
2. Компоненты сортируются естественным образом и добавляются в глобальные переменные по первой большой букве.

  ```ruby
  C => computer
  E => eeprom
  I => inventory_controller
  R => robot
  T => trading
  ...
  ```
<!--  -->

Дополнительные глобальные переменные:

- `i` - текущий индекс цикла, начиная с 0.
  > Вы можете добавить число после `i`, чтобы получить его по модулю +1.
  > ```lua
  > i16 = i % 16 + 1
  > ```
- `sleep(seconds: number = 1)`
- `write(...)` - ошибка с сериализованным выводом.
- `api(shortName: string, obj?: table)` - написать полное имя сокращения.

## Сокращение

Поскольку имя робота или дрона может содержать только `64` символа, указатели должны быть сокращены.

Таким образом, вместо написания полного имени указателя, вы можете его сократить. Например, вместо написания `robot.use(3)`, вы можете написать `r.u(3)` или даже `Ru3`.

Правила сокращения:

1. Если ключ имеет точное не-nil совпадение, оно будет возвращено.
    > `R.use(3)` - `R` это глобальная переменная, представляющая компонент `robot`.

2. Сокращение должно содержать первую букву, а затем, по желанию, любое количество оставшихся букв.
    > ```lua
    > tbl.unk => table.unpack
    > t.u => table.unpack
    > ```

3. Если несколько имен имеют одинаковую первую букву, будет выбрано **самое короткое**, **алфавитно** отсортированное имя.
    > ```lua
    > robot.s   -- robot.slot
    > robot.se  -- robot.space
    > robot.sel -- robot.select
    > ```

4. Большая первая буква с точкой `.` может использоваться без точки.
    > ```lua
    > -- Те же указатели
    > robot.use == R.use == Ruse == Ru
    > ```

5. Число в конце сокращения будет вызывать сокращение как функцию с этим числом в качестве первого аргумента.
    > ```lua
    > Ru3 -- robot.use(3)
    > s10 -- sleep(10)
    > ```
    В то же время, если это таблица, а не функция, все ключи таблицы будут естественно отсортированы и возвращен `N`-й элемент.
    > ```lua
    > R16 -- robot.select
    > ```
    Смотрите больше в [Числовом Словаре](#числовой-словарь).

6. Локальные переменные не могут быть сокращены.
    > ```lua
    > local query = {len=4}
    > q.l -- Исключение: q не определено
    > query.l -- l не определено
    > query.len -- 4     > ```

## Lodash `_`

Специальная вспомогательная функция нижнего подчеркивания `_`.

### Индексация `_`

<!-- indexing _ -->
- **Использование `_` с числами `_123`**
  Вернет новый список-массив с длиной числа.
  Если первая цифра `0`, таблица будет с нулевым индексом.
  > ```lua
  > _8  -- возвращает {1,2,3,4,5,6,7,8}
  > _08 -- возвращает {[0]=0,1,2,3,4,5,6,7}
  > ```
- **Использование `_` со словами `_abc`**
  Создает функцию, которая будет записывать результат в переменную `abc`.
  Функция возвращает переданное значение.
  Обратите внимание, что `_abc` функциональна.
  > ```lua
  > _a(4) -- Записывает `4` в глобальную переменную `a`, возвращает 4
  > _a'Ru3' -- Записывает функцию, выполняющую `Ru3`, в глобальную переменную `a`
  > _a^Ru -- Создает функцию, записывающую результат `Ru` в глобальную переменную `a`
  > b._a^3 -- b.a = 3
  > ```
<!--  -->

### Вызов `_`

<!-- calling _ -->
- **Использование `_` на строке**
  Загрузит код внутри этой строки и вернет его как функцию. Вызов этой функции всегда безопасен для ошибок — если внутри произойдет исключение, функция просто вернет `nil`.

  > ```lua
  > _'Rm,s2'()(0) -- вызывает `sleep(2),robot.move(0)`
  > ```
  > Обратите внимание, что в этом примере функция `_` возвращает два значения — функцию `robot.move` и результат `sleep(2)`. Только когда мы вызываем возвращенные значения во второй раз, выполняется `robot.move(0)`.

- **Использование `_` на *таблице* или *функции***
  Преобразует их в специальную таблицу `_{}` или функцию `_''` для использования с [Функциональным Программированием](#функциональное-программирование).
  > ```lua
  >  {1,2}^1 -- вызовет ошибку
  > _{1,2}^1 -- вернет {1,1} (см. Функциональное Программирование)
  > ```

## Функциональное Программирование

Любая таблица или функция, которую вы можете получить из глобальной переменной, будет преобразована в специальную таблицу `_{}`.

Эта таблица улучшена дополнительными метаметодами операторов, которые помогают с функциональным стилем программирования.

Любая итерация или вызовы `pairs()` на этих преобразованных таблицах будут выводить элементы в естественно отсортированном порядке.

**Операторы** ведут себя по-разному в зависимости от левой и правой стороны оператора.

Обратите внимание, что когда обнаруживается `строка`, она загружается и преобразуется в функцию по принципу `_'fnc'`.

### Приоритет

Приоритет операторов в Lua следует таблице ниже, от высшего к низшему приоритету:

1. `^`
2. унарные `not` `#` `-` `~`
3. `*` `/` `//` `%`
4. `+` `-`
5. `..`
6. `<<` `>>`
7. `&`
8. `~`
9. `|`
10. `<` `>` `<=` `>=` `~=` `==`
11. `and`
12. `or`

<!--
███╗   ███╗ █████╗ ██████╗
████╗ ████║██╔══██╗██╔══██╗
██╔████╔██║███████║██████╔╝
██║╚██╔╝██║██╔══██║██╔═══╝
██║ ╚═╝ ██║██║  ██║██║
╚═╝     ╚═╝╚═╝  ╚═╝╚═╝
-->

### Map `^`, `+`, или `&`

`^`, `+`, и `&` операторы делают то же самое. Их три, только для управления приоритетом.

- **Примечание¹:** `^` ассоциируется справа. Это означает, что сначала будет вычислена правая сторона.

- **Примечание²:** Вы также можете вызывать *невызываемые* таблицы. `t(x)` то же самое, что `t^x`. *Невызываемые* таблицы — это таблицы без метатаблицы `__call`.
  Пример (map `t^f`):
  ```lua
  _{1,2,3}'0' -- _{0,0,0}
  ```

<table>
<tr>
  <th>Левая сторона</th><th>Правая сторона</th><th>Результат</th>
</tr>

<tr>
  <td rowspan=3>Таблица</td><td>Функция</td><td>

<!-- t^f -->
Классическая карта
```lua
_{4,5,6}^f -- {f(4),f(5),f(6)}
```
<!--  -->

</td></tr>
<tr><td>Таблица</td><td>

<!-- t^t -->
Выбор индексов
```lua
_{4,5,6}^{3,1} -- {6,4}
```
<!--  -->

</td></tr>
<tr><td>Число, Булево значение</td><td>

<!-- t^n -->
Добавление значения в КОНЕЦ таблицы
```lua
_{1,[3]=3,a=6,[4]=4}^5
-- _{1,3=3,4=4,5=5,a=6}
```
<!--  -->

</td></tr>
<tr><td rowspan=3>Функция</td><td>Функция</td><td>

<!-- f^f -->
Композиция
```lua
f^g -- (...)=>f(g(...))
```
<!--  -->

</td></tr>
<tr><td>Таблица</td><td>

<!-- f^t -->
Распаковка как аргументы
```lua
f^{1,2,3} -- f(1,2,3)
```
<!--  -->

</td></tr>
<tr><td>Число, Булево значение</td><td>

<!-- f^n -->
Простой вызов
```lua
f^1 -- f(1)
```
<!--  -->

</td></tr>
<tr><td rowspan=2>Число, Булево значение</td><td>Таблица</td><td>

<!-- n^t -->
Получение по числовому или булевому индексу
```lua
2^_{4,5,6} -- 5
```
<!--  -->

</td></tr>
<tr><td>Функция</td><td>

<!-- n^f -->
<sub>Не реализовано</sub>
<!--  -->

</td></tr>
</table>

<!--
██╗      █████╗ ███╗   ███╗██████╗ ██████╗  █████╗
██║     ██╔══██╗████╗ ████║██╔══██╗██╔══██╗██╔══██╗
██║     ███████║██╔████╔██║██████╔╝██║  ██║███████║
██║     ██╔══██║██║╚██╔╝██║██╔══██╗██║  ██║██╔══██║
███████╗██║  ██║██║ ╚═╝ ██║██████╔╝██████╔╝██║  ██║
╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═════╝ ╚═════╝ ╚═╝  ╚═╝
-->

### Лямбда `-` `/` `|`

<table>
<tr>
  <th>Левая сторона</th><th>Правая сторона</th><th>Результат</th>
</tr>

<tr>
  <td rowspan=3>Таблица</td><td>Функция</td><td>

<!-- t/f -->
Фильтр, оставляет только значения, являющиеся [Истинными](#истинные)
```lua
_{4,5,6,7}/'v%2' -- {5,7}
```
<!--  -->

</td></tr>
<tr><td>Таблица</td><td>

<!-- t/t -->
<sub>Не реализовано</sub>
<!--  -->

</td></tr>
<tr><td>Число, Булево значение</td><td>

<!-- t/n -->
Удаление индекса
```lua
_3/2 -- {1=1,3=3}
```
<!--  -->

</td></tr>
<tr><td rowspan=3>Функция</td><td>Функция</td><td>

<!-- f/f -->
Обратная композиция
```lua
f/g -- (...)=>g(f(...))
```
<!--  -->

</td></tr>
<tr><td>Таблица</td><td>

<!-- f/t -->
Простой вызов
```lua
f/R -- f(R)
```
<!--  -->

</td></tr>
<tr><td>Число, Булево значение</td><td>

<!-- f/n -->
Композиция
```lua
f/1 -- (...)=>f(1,...)
```
<!--  -->

</td></tr>
<tr><td rowspan=2>Число, Булево значение</td><td>Таблица</td><td>

<!-- n/t -->
Получение по модулю
```lua
i/t -- t[i % #t + 1]
```
<!--  -->

</td></tr>
<tr><td>Функция</td><td>

<!-- n/f -->
Вращающаяся композиция
```lua
2/f -- (...)=>f(..., 2)
```
<!--  -->

</td></tr>
</table>

<!--
██╗      ██████╗  ██████╗ ██████╗
██║     ██╔═══██╗██╔═══██╗██╔══██╗
██║     ██║   ██║██║   ██║██████╔╝
██║     ██║   ██║██║   ██║██╔═══╝
███████╗╚██████╔╝╚██████╔╝██║
╚══════╝ ╚═════╝  ╚═════╝ ╚═╝
-->

### Цикл `~` или `*`

<table>
<tr>
  <th>Левая сторона</th><th>Правая сторона</th><th>Результат</th>
</tr>

<tr>
  <td rowspan=3>Таблица</td><td>Функция</td><td>

<!-- t~f -->
<sub>Не реализовано</sub>
<!--  -->

</td></tr>
<tr><td>Таблица</td><td>

<!-- t~t -->
<sub>Не реализовано</sub>
<!--  -->

</td></tr>
<tr><td>Число, Булево значение</td><td>

<!-- t~n -->
<sub>Не реализовано</sub>
<!--  -->

</td></tr>
<tr><td rowspan=3>Функция</td><td>Функция</td><td>

<!-- f~f -->
Пока истинно, делай
```lua
f~g -- пока истинно(g(j++)) делай f(j)
```
<!--  -->

</td></tr>
<tr><td>Таблица</td><td>

<!-- f~t -->
<sub>Не реализовано</sub>
<!--  -->

</td></tr>
<tr><td>Число, Булево значение</td><td>

<!-- f~n -->
Цикл for
```lua
f~n -- for j=1,TONUMBER(n) do f(j) end
```
<!--  -->

</td></tr><tr><td rowspan=2>Число, Булево значение</td><td>Таблица</td><td>

<!-- n~t -->
<sub>Не реализовано</sub>
<!--  -->

</td></tr>
<tr><td>Функция</td><td>

<!-- n~f -->
То же, что и `f~n`, но без передачи индекса
```lua
n~f -- for j=1,TONUMBER(n) do f() end
```
<!--  -->

</td></tr>
</table>

<!--
██╗   ██╗███╗   ██╗ █████╗ ██████╗ ██╗   ██╗
██║   ██║████╗  ██║██╔══██╗██╔══██╗╚██╗ ██╔╝
██║   ██║██╔██╗ ██║███████║██████╔╝ ╚████╔╝
██║   ██║██║╚██╗██║██╔══██║██╔══██╗  ╚██╔╝
╚██████╔╝██║ ╚████║██║  ██║██║  ██║   ██║
 ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝
-->

### Унарные операторы

<table>
<tr>
  <th>Унарный оператор</th><th>Объект</th><th>Результат</th>
</tr>

<tr><td rowspan=2>

`~`</td><td>Функция</td><td>

<!-- ~f -->
Пока истинно, делай
```lua
~f -- повторять пока не истинно(f())
```
<!--  -->

</td></tr>
<tr><td>Таблица</td><td>

<!-- ~t -->
Сглаживание таблицы, используя числовые индексы.

> - Порядок элементов может быть разным
> - Все ключи таблицы будут преобразованы в индексированные
> - Только 1 уровень сглаживания

```lua
~_{1,{2,3},{4,a=5,b={6,c=7}}}
-- {1,2,3,4,5,{6,c=7}}
```
<!--  -->

</td></tr>

<tr><td rowspan=2>

`-`</td><td>Функция</td><td>

<!-- -f -->
Создать функцию, результат которой будет инвертирован.
Если результат `истинный`, возвращает `0`. Возвращает `1` в противном случае.
```lua
-- id здесь функция, возвращающая свой первый аргумент
(-id)(0) -- 1
(-id)(4) -- 0
(- -id)(4) -- 1
```
<!--  -->

</td></tr>
<tr><td>Таблица</td><td>

<!-- -t -->
Обмен ключей и значений

```lua
-_{'a','b','c'}
-- {a=1,b=2,c=3}
```
<!--  -->

</td></tr>

<tr><td>

`#`</td><td>Функция</td><td>

<!-- #f -->
Создать функцию, которая будет оборачивать свой результат в таблицу.
Полезно для функций, возвращающих несколько значений.
```lua
-- Предположим, `f(n)` возвращает три значения - 2,3,n
f&4   -- 2
#f&4  -- _{2,3,4}
```
<!--  -->

</td></tr>

</table>

### Истинные значения

Знач ение считается "истинным", если оно не является "ложным".

"Ложные" значения:

1. `false` или `nil`
2. `''` (пустая строка)
3. `0` (ноль)
4. `nan` (не число, `n ~= n`)
5. `inf` или `-inf` (результат `1/0` или `-1/0`)

## Макросы

В программе есть несколько предопределенных макросов - символов, которые будут заменены везде на другой текст.

```javascript
! => '()'
ⓐ => ' и '
ⓞ => ' или '
ⓝ => ' не '
ⓡ => ' вернуть '
⒯ => '(истина)'
⒡ => '(ложь)'
```

## Примеры

- **Перемещение между двумя точками и выполнение их метки**

  > Требуемые улучшения: ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__17.png "Улучшение Инвентаря"), ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__19.png "Улучшение Навигации")

  ![Дрон перемещается между точками](https://i.imgur.com/36HdGzO.gif)

  Имя дрона:
  ```lua
  P=i/Nf300ⓡDm^Pp,s/1~'Dg0>1',_(Pl)
  ```
  * `Nf300`: Выполнить `navigation.findWaypoints(300)`.
  * `i/Nf300`: `i` - индекс выполнения скрипта. `i / table` - "Получение по индексу модуля" `t[i % #t + 1]`.
  * `P=i/Nf300`: Записать в глобальную переменную `P` различные точки каждый цикл скрипта.
  * `ⓡ`: будет заменено на ` вернуть `
  * `Dm^Pp`: вызов `drone.move(table.unpack(P.position))`.
  * `s/1~'Dg0>1'` => `пока drone.getOffset() > 1 делать sleep(1)`.
  * `_(Pl)`: Загрузить `P.label` как код Lua. Эта загруженная функция будет [возвращена и выполнена](#возврат).

  Метки точек. Первая просто всасывает снизу, вторая итерирует по 4 слотам и сбрасывает вниз.
  ```lua
  _'Dsk0'~4
  Dsel-'Dd0'~4
  ```

- **Зигзаг + Использование вниз, полезно для ферм**

  > Требуемые улучшения: нет

  ![Робот на ферме](https://i.imgur.com/YTd5idO.gif)

  Имя робота:
  ```lua
  m,t=_'Rm3,Ru0',Rtn/(i2>1)ⓡ~m,t!,_'m!,t!'!ⓞt/m
  ```
  * `m,t=_'Rm3,Ru0',Rtn/(i2>1)`: определить две функции для движения и поворота
    - `_'Rm3,Ru0'`: определить функцию `Rm3,Ru0`, которая будет двигаться вперед и использовать инструмент вниз
    - `Rtn/(i2>1)`: это создает функцию, которая будет вызывать `Rtn` (`robot.turn`) с аргументом `i2>1`. `i2` - сокращение для `i%2+1`
  * `~m`: Заставляет робота двигаться вперед, пока он не сможет двигаться.
  * `t!`: просто поворачивает
  * `_'m!,t!'!ⓞt/m`: Двигаться и поворачиваться. Если движение не удалось, повернуться и двигаться снова.

- **Торговый бот**

  > Требуемые улучшения: ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__29.png "Улучшение Торговли"), ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__17.png "Улучшение Инвентаря"), ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__18.png "Улучшение Контроллера Инвентаря")

  ![Торговый робот](https://i.imgur.com/HEgNabM.png)

  Имя робота:
  ```lua
  Rsel-'Rd0'~RiS0,IsF/0~Igz0,Tg0'~tr'
  ```
  * `Rsel-'Rd0'~RiS0`: Выбрать каждый слот и сбросить вниз
    > - `'Rd0'`: это функция, которая будет вызывать `robot.drop(0)` при выполнении.
    > - `RiS0`: сокращение для `robot.inventorySize(0)`. Обратите внимание, что эта функция не использует аргументы, поэтому мы можем вызвать ее с `0`
    > - `Rsel`: сокращение для `robot.select`. Обратите внимание, что мы использовали оператор `-`, который такой же, как `/`, но имеет более низкий приоритет
  * `IsF/0~Igz0`: Для каждого слота инвентаря снизу `inventory_controller.getInventorySize(0)` вызвать `inventory_controller.suckFromSlot(0, k)`
  * `Tg0'~tr'`: Торговать всеми товарами.
    > - `~tr`: Вызывать `trade()` пока возвращает истину. Обратите внимание, что внутри этой функции все аргументы открыты как глобальные, поэтому мы можем получить доступ к `trade` как к глобальной переменной (на самом деле это `upvalue`)

  Есть другой вариант имени робота, более продвинутый. Он будет забирать только предметы, которые действительно требуются для торговли. Эта программа жестко запрограммирована для работы с **внутренним и внешним** инвентарем размером 16:
  ```lua
  -- Торговать всем
  a=-~Tg0"_{g!}'n',~tr"ⓡ_16&R16-'Rd0'&IgI/0&'a[n]ⓐI8/0&k'

  -- Не продавать изумруды [id==388]
  a=-~Tg0'388^-g0ⓞ{g0.n,~tr}'ⓡ_16&R16-'Rd0'&IgI/0&'a[n]ⓐI8/0&k'
  ```

- **Создатель рун**

  > Требуемые улучшения: ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__17.png "Улучшение Инвентаря"), ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__18.png "Улучшение Контроллера Инвентаря")

  Поместите ингредиенты в первые 6 слотов робота. Живой камень на 7-м, палочку на 8-м.

  <img alt="Настройка создания рун" src="https://i.imgur.com/OXRuYs3.png" width="25%">
  <img alt="Робот создает руны" src="https://i.imgur.com/KqlJqMw.gif">

  Имя робота:
  ```lua
  _8/'Rsel^v,v==7ⓐ{s3,Rm1,Rd(3,1),Rm0}ⓞ{Ie!,Ru3,Ie!}'
  ```
  * `Rsel^v`: Выбрать слот по очереди
  * `v==7ⓐ{s3,Rm1,Rd(3,1),Rm0}`: если это 7-й слот с Живым камнем, подождать 3 секунды до завершения крафта, затем сбросить Камень сверху.
  * `Ie!,Ru3,Ie!`: Для других слотов - просто кликнуть правой кнопкой мыши с предметом

- **Ферма одиночных деревьев**

  > Требуемые улучшения: ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__17.png "Улучшение Инвентаря"), ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__18.png "Улучшение Контроллера Инвентаря")

  Этот робот предназначен для использования с саженцами Forestry, которые обычно не могут быть поставлены как блоки, но требуют клика правой кнопкой мыши для посадки.
  Кроме того, роботу нужен *неразрушимый* Широкий Топор из TCon с чертой *Глобальный Путешественник*. Кроме того, мой топор имеет черту *Удобрение* - клик правой кнопкой мыши для удобрения.
  Поставьте робота на контейнер с саженцами.

  ![Робот фермит деревья](https://i.imgur.com/I9W39B0.gif "Робот фермит деревья")

  Имя робота:
  ```lua
  #(1|#Rdt&3)<6ⓐRsw/3-s/1-Rsk/0-Ie-Ru/3-IeⓞRu3,s
  ```
  * `(1|#Rdt&3)`: Обнаружить блок перед собой, выбрать второе возвращаемое значение - [описание блока](https://ocdoc.cil.li/component:robot)
  * `#()<6`: хитрость, чтобы определить, является ли блок твердым
  * `Rsw/3-s/1`: Срубить все дерево, подождать 1 секунду
  * `Rsk/0-Ie-Ru/3-Ie`: Всосать саженец снизу, затем посадить его. Обратите внимание, что `Rsk` получает одно значение от `sleep` возврата
  * `Ru3,s`: Удобрить саженец

- **Другие примеры**

  * *Круговой шахтер*. Используя Молот с частью из Алумита (черта Глобальный Путешественник). Поставьте Робота под землю, поместите стак Блоков Угля в выбранный слот робота. Робот начнет кружить вокруг, добывая все на своем пути.
    > Требуемые улучшения: ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__27.png "Улучшение Парения (Уровень 1)")
    >
    > Дополнительные улучшения: ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__17.png "Улучшение Инвентаря"), ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__16.png "Улучшение Генератора")
    ```lua
    Gi,_'Rm3,Rsw3'~i*2,Rtn⒯
    ```

  * *Робот для сортировки дропа мобов*. Берет снизу, предметы, подлежащие повреждению, вверх, остальные - вперед.
    > Требуемые улучшения: ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__17.png "Улучшение Инвентаря"), ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__18.png "Улучшение Контроллера Инвентаря")
    ```lua
    Rd|3%2^(IsF(0,i%Igz0+1)ⓐIgSII!.mDⓞ2)
    ```

  * *Открыватель кошек*. Берет 16 предметов перед собой, кликает их правой кнопкой мыши, затем сбрасывает инвентарь вверх.
    > Требуемые улучшения: ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__17.png "Улучшение Инвентаря"), ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__18.png "Улучшение Контроллера Инвентаря")
    ```lua
    Rsk/3&16ⓐIe!,~_'Ru0',_16/Rc|Rsel/'Rd1'
    ```

  * *Компрессионный бот*. Берет спереди, крафтит 3x3, затем сбрасывает назад.
    > Требуемые улучшения: ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__11.png "Улучшение Крафта"), ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__17.png "Улучшение Инвентаря"), ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__18.png "Улучшение Контроллера Инвентаря")
    ```lua
    -(_16-Rc&12)|'Rd3'&Rsel,IsF/3/'_11/8/4&Rc!/9/RtT'|i81,Cc
    ```

  * *Бот для неразложимых предметов*. Берет предмет перед собой только если они неразложимы и кладет их наверх. Если не может сбросить предмет наверх, толкает вверх и ставит блок.
    > Заполните все слоты робота, кроме 1. Слот 9 должен иметь новые инвентари для неразложимых предметов.
    >
    > Требуемые улучшения: ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__20.png "Улучшение Поршня"), ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__17.png "Улучшение Инвентаря"), ![](https://github.com/Krutoy242/mc-icons/raw/master/i/opencomputers/upgrade__18.png "Улучшение Контроллера Инвентаря")
    ```lua
    (IgSI/3&_a^i1728ⓞ{}).mS^_{_'IsF/3&a,Rd1ⓞ{Pps1,Rsel9,Rp1,Rsel1}'}
    ```

## Дополнительно

### Числовой Словарь

Это не настоящий словарь - всю эту информацию можно сгенерировать в игре для каждой таблицы.

Чтобы получить отсортированные числовые значения, назовите робота таким образом, где `T` - это указатель на желаемую таблицу:
```lua
e((~-T'k')"'\\n'..k..' '..v")
```

Шпаргалка для наиболее распространенных таблиц:

<table>
<tr><td>

> ```ruby
> robot:
> R1  use
> R2  drop
> R3  fill
> R4  move
> R5  name
> R6  slot
> R7  suck
> R8  turn
> R9  type
> R10 count
> R11 drain
> R12 place
> R13 space
> R14 swing
> R15 detect
> R16 select
> R17 address
> R18 compare
> R19 compareTo
> R20 tankCount
> R21 tankLevel
> R22 tankSpace
> R23 durability
> R24 selectTank
> R25 transferTo
> R26 compareFluid
> R27 getLightColor
> R28 inventorySize
> R29 setLightColor
> R30 compareFluidTo
> R31 transferFluidTo
> ```

</td><td>

> ```ruby
> inventory_controller:
> I1  slot
> I2  type
> I3  equip
> I4  store
> I5  address
> I6  dropIntoSlot
> I7  getAllStacks
> I8  suckFromSlot
> I9  compareStacks
> I10 storeInternal
> I11 getStackInSlot
> I12 isEquivalentTo
> I13 getInventoryName
> I14 getInventorySize
> I15 getSlotStackSize
> I16 compareToDatabase
> I17 areStacksEquivalent
> I18 getSlotMaxStackSize
> I19 getItemInventorySize
> I20 dropIntoItemInventory
> I21 suckFromItemInventory
> I22 compareStackToDatabase
> I23 getStackInInternalSlot
> ```

> ```ruby
> trade:
> 1 type
> 2 trade
> 3 getInput
> 4 getOutput
> 5 isEnabled
> 6 getMerchantId
> ```

</td><td>

> ```ruby
> geolyzer:
> G1 scan
> G2 slot
> G3 type
> G4 store
> G5 detect
> G6 address
> G7 analyze
> G8 canSeeSky
> G9 isSunVisible
> ```

> ```ruby
> tank_controller:
> T1 fill
> T2 slot
> T3 type
> T4 drain
> T5 address
> T6 getTankCount
> T7 getTankLevel
> T8 getFluidInTank
> T9 getTankCapacity
> T10 getTankLevelInSlot
> T11 getFluidInTankInSlot
> T12 getTankCapacityInSlot
> T13 getFluidInInternalTank
> ```

</td></tr>
</table>

## Ссылки

- [Репозиторий с исходным кодом и readme](https://github.com/Krutoy242/lostuser)
- Модпак, для которого был запрограммирован этот робот: [Enigmatica 2: Expert - Extended](https://www.curseforge.com/minecraft/modpacks/enigmatica-2-expert-extended)
